<!DOCTYPE html>

<script>
  const nRows = 1000;
  const nRuns = 1000;
  let templateHtml;

  // This is the benchmark itself.
  let id = 1;
  function runBenchmarkRow(perfs, parent) {
    const idStr = `id_${id++}`;
    let rowTplBaseline,html,tplClone,trEl,td2,names,children,trEl3,bAttr,classList,textContent,textData,treeWalker;
    measure(perfs, /*repeatCall*/"first", 'non-trivial', 4, 'createElement', () => {
      rowTplBaseline = document.createElement("template");
    });

    measure(perfs, /*repeatCall*/"first", 'non-trivial', 1, 'stringInterp', () => {
      html =
`<tr id=${idStr} class="a b" a=1 b=2 c=3 d=4 e=5 f=6>
  <td></td>
  <td g=7>Some text here</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>`;
    });
    templateHtml = templateHtml || html;

    measure(perfs, /*repeatCall*/"first", 'non-trivial', 2, 'innerHTML', () => {
      rowTplBaseline.innerHTML = html;
    });

    // DocumentFragment::cloneNode(true)
    measure(perfs, /*repeatCall*/"first", 'non-trivial', 3, 'templateClone', () => {
      tplClone = rowTplBaseline.content.cloneNode(true);
    });

    // -------- Repeated calls below - note that they all work on the same set of elements --------

    ["first","repeat"].forEach(repeatCall => {
      measure(perfs, repeatCall, 'trivial', 6, 'firstElementChild', () => {
        trEl = tplClone.firstElementChild;
      });

      const firstTd = trEl.firstElementChild;
      measure(perfs, repeatCall, 'trivial', 7, 'nextSibling', () => {
        td2 = firstTd.nextSibling;
      });

      measure(perfs, repeatCall, 'trivial', 9, 'getAttributeNames', () => {
        names = trEl.getAttributeNames();
      });

      measure(perfs, repeatCall, 'trivial', 8, 'children', () => {
        children = trEl.children;
      });

      measure(perfs, repeatCall, 'non-trivial', 5, 'appendChild', () => {
        parent.appendChild(tplClone);
      });

      measure(perfs, repeatCall, 'trivial', 10, 'getElementById', () => {
        trEl3 = document.getElementById(idStr);
      });

      measure(perfs, repeatCall, 'trivial', 12, 'getAttribute', () => {
        bAttr = trEl.getAttribute('b');
      });

      measure(perfs, repeatCall, 'trivial', 11, 'classList', () => {
        classList = trEl3.classList;
      });

      measure(perfs, repeatCall, 'trivial', 13, 'setAttribute', () => {
        trEl.setAttribute('c','3');
      });

      measure(perfs, repeatCall, 'trivial', 14, 'setAttribute_same_value', () => {
        trEl.setAttribute('c','3');
      });

      const listener = () => console.log('foo');
      measure(perfs, repeatCall, 'non-trivial', 15, 'addEventListener', () => {
        trEl.addEventListener('click',listener);
      });

      measure(perfs, repeatCall, 'non-trivial', 16, 'textContent', () => {
        textContent = parent.textContent;
      });

      const secondChild = parent.querySelector('td[g]');
      const thirdChild = secondChild.nextElementSibling;
      measure(perfs, repeatCall, 'non-trivial', 17, 'insertBefore', () => {
        trEl.insertBefore(thirdChild,secondChild);
      });

      const textNode = secondChild.firstChild;
      measure(perfs, repeatCall, 'trivial', 15, 'data', () => {
        textData = textNode.data;
      });

      const div = thirdChild.appendChild(document.createElement('div'));
      measure(perfs, repeatCall, 'non-trivial', 18, 'attachShadow', () => {
        div.attachShadow({mode: 'open'});
      });

      measure(perfs, repeatCall, 'non-trivial', 19, 'createTreeWalker', () => {
        treeWalker = document.createTreeWalker(parent, NodeFilter.SHOW_ALL);
      });

      const iframe = document.querySelector("iframe");
      const iframeEl = iframe.contentDocument.body.firstChild;
      measure(perfs, repeatCall, 'non-trivial', 20, 'importNode', () => {
        const iframeElClone = document.importNode(iframeEl, true);
      });


      // Use all of the results, to ensure nothing is optimized out. Plus verify things worked as expected.
      assert(td2.nextSibling.nextSibling.getAttribute('g') === '7' && names.length === 8 && children.length === 6 &&
          bAttr === '2' && classList.length === 2 && textContent.length > 0 && thirdChild.children.length === 1 &&
          textNode.nodeType === 3 && textData.length > 10 && iframeEl.outerHTML === "<div></div>" &&
          'currentNode' in treeWalker,'Broken behavior');

      // Cleanup for repeat:
      trEl.setAttribute('c','not 3');
      trEl.removeEventListener('click',listener);
      trEl.insertBefore(secondChild,thirdChild);
      thirdChild.replaceChildren();
      while (parent.childNodes.length) {
        tplClone.appendChild(parent.firstChild);
      }
    });
  }
</script>

<fieldset style="display:flex; border:0" id="controls">
  <div>
    <button id="run_baseline"></button>
    <pre id=baseline_log></pre>
  </div>
</fieldset>
<table style="display:none"><tbody></tbody></table>
<div>
  Some notes about the measurement methodology:
  <ul>
    <li>The benchmark repeats a series of operations on a small template, and
        appends that template to a table. It repeats this
        <span id="nrows">nRows</span> times. It then clears the table, and
        repeats the table building process <span id="nruns">nRuns</span> times.
        The point of the double-loop is to ensure any effects of the DOM size
        are measured, at least to first order.</li>
    <li>Each operation is measured using <code>Performance.now()</code>. On
        Chromium browsers, the precision of this timer is 100us, and on WebKit
        and Gecko browsers, it is 1000us.</li>
    <li>Because each operation being measured runs on the order of ~1us, but is
        being measured with a 100us (or 1000us) resolution timer, we must rely
        on "dithering" to average across N measuremeents, improving the
        precision by 1/N. N must therefore be at least 1000, and preferably
        much higher (~100k). The value used here is <span id="ntot"></span>.</li>
    <li>Garbage collection can occur during the benchmark run, which will be
        additive to the time of the measurment being made at the time. It is
        hard to control GC timing on non-Chromium browsers (pointers appreciated
        if you know how!). To be fair, GC is just assumed to be a fixed time
        addition to all measurements and is ignored. Note that noise reduction
        methods such as median(), which otherwise might be usable to remove the
        periodic GC noise, cannot be used due to the resolution issue mentioned
        above.</li>
  </ul>
</div>
<iframe style="display:none" srcdoc="<div></div>"></iframe>

<script>
  document.querySelector(
    "button#run_baseline"
  ).textContent = `Run benchmark, ${nRows} rows, ${nRuns} runs`;
  document.getElementById('nrows').textContent = nRows;
  document.getElementById('nruns').textContent = nRuns;
  document.getElementById('ntot').textContent = nRows*nRuns;

  function measure(perfs,repeatCall,category,index,field, operation) {
    if (!(field in perfs)) {
      perfs[field] = {};
    }
    if (!(repeatCall in perfs[field])) {
      perfs[field][repeatCall] = {sum:0, count:0, index, category};
    }
    const startTime = performance.now();
    operation();
    const endTime = performance.now();
    perfs[field][repeatCall].sum += endTime - startTime;
    perfs[field][repeatCall].count++;
  }

  function assert(cond,msg) {
    if (!cond) {
      msg = `Unexpected condition encountered in benchmark: ${msg}`;
      document.querySelector("#baseline_log").textContent = msg;
      throw Error(msg);
    }
  }

  async function runAndMeasureBenchmark() {
    controls.disabled = true;
    await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)));
    setTimeout(() => {controls.disabled = false},0);
    const tbodyRef = document.querySelector("tbody");
    const perfs = {}; // Record overall, across rows and runs.

    for (let i = 0; i < nRuns; i++) {
      // Reset the table between runs.
      document.querySelector("tbody").replaceChildren();

      for (let i = 0; i < nRows; i++) {
        runBenchmarkRow(perfs, tbodyRef);
      }
    }

    // Convert to average times, plus double check for bad names and indices.
    let correctCount;
    Object.keys(perfs).forEach(key => {
      ["first","repeat"].forEach(repeatCall => {
        if (repeatCall in perfs[key]) {
          perfs[key][repeatCall].averageTime = perfs[key][repeatCall].sum / perfs[key][repeatCall].count;
          if (!correctCount) {
            correctCount = perfs[key][repeatCall].count;
          } else {
            assert(correctCount == perfs[key][repeatCall].count,`Duplicate name for ${key}`);
          }
        }
      });
    });
    return perfs;
  }

  document.querySelector("button#run_baseline").addEventListener("click", async () => {

    // Run the benchmark:
    const perfs = await runAndMeasureBenchmark();

    let report = '<table><thead><tr><th>Type</th><th>Benchmark</th><th>Time (us/call)</th></tr></thead>';
    Object.keys(perfs)
      .sort((a, b) => {
        return perfs[a].first.category.localeCompare(perfs[b].first.category) ||
            perfs[a].first.index - perfs[b].first.index;
      })
      .forEach(key => {
      ["first","repeat"].forEach(repeatCall => {
        if (repeatCall in perfs[key]) {
          report += `<tr>
            <td>${perfs[key][repeatCall].category}</td>
            <td>${key}${repeatCall !== "first" ? " (repeat)" : ""}</td>
            <td>${(1000*perfs[key][repeatCall].averageTime).toFixed(3)}</td>
          </tr>`;
        }
      });
    });
    report += `</table><br><br>template:<br>`;
    const log = document.querySelector("#baseline_log");
    log.innerHTML = report;
    const pre = document.createElement('pre');
    pre.innerText = templateHtml;
    log.appendChild(pre);
  });
</script>
