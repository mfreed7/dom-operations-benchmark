<!DOCTYPE html>

<iframe style="display:none" srcdoc="<div></div>"></iframe>

<script>
  const nRows = 1000;
  const nRuns = 1000;
  let templateHtml;

  // This is the benchmark itself.
  let id = 1;
  function runBenchmarkRow(perfs, parent) {
    const idStr = `id_${id++}`;
    let rowTplBaseline,html,tplClone,trEl,td2,names,children,trEl3,bAttr,classList,textContent,textData,treeWalker;
    measure(perfs, /*repeatCall*/"first", 'non-trivial', 4, 'createElement', () => {
      rowTplBaseline = document.createElement("template");
    });

    measure(perfs, /*repeatCall*/"first", 'non-trivial', 1, 'stringInterp', () => {
      html =
`<tr id=${idStr} class="a b" a=1 b=2 c=3 d=4 e=5 f=6>
  <td></td>
  <td g=7>Some text here</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>`;
    });
    templateHtml = templateHtml || html;

    measure(perfs, /*repeatCall*/"first", 'non-trivial', 2, 'innerHTML', () => {
      rowTplBaseline.innerHTML = html;
    });

    // DocumentFragment::cloneNode(true)
    measure(perfs, /*repeatCall*/"first", 'non-trivial', 3, 'templateClone', () => {
      tplClone = rowTplBaseline.content.cloneNode(true);
    });

    // -------- Repeated calls below - note that they all work on the same set of elements --------

    ["first","repeat"].forEach(repeatCall => {
      measure(perfs, repeatCall, 'trivial', 6, 'firstElementChild', () => {
        trEl = tplClone.firstElementChild;
      });

      const firstTd = trEl.firstElementChild;
      measure(perfs, repeatCall, 'trivial', 7, 'nextSibling', () => {
        td2 = firstTd.nextSibling;
      });

      measure(perfs, repeatCall, 'trivial', 9, 'getAttributeNames', () => {
        names = trEl.getAttributeNames();
      });

      measure(perfs, repeatCall, 'trivial', 8, 'children', () => {
        children = trEl.children;
      });

      measure(perfs, repeatCall, 'non-trivial', 5, 'appendChild', () => {
        parent.appendChild(tplClone);
      });

      measure(perfs, repeatCall, 'trivial', 10, 'getElementById', () => {
        trEl3 = document.getElementById(idStr);
      });

      measure(perfs, repeatCall, 'trivial', 12, 'getAttribute', () => {
        bAttr = trEl.getAttribute('b');
      });

      measure(perfs, repeatCall, 'trivial', 11, 'classList', () => {
        classList = trEl3.classList;
      });

      measure(perfs, repeatCall, 'trivial', 13, 'setAttribute', () => {
        trEl.setAttribute('c','3');
      });

      measure(perfs, repeatCall, 'trivial', 14, 'setAttribute_same_value', () => {
        trEl.setAttribute('c','3');
      });

      const listener = () => console.log('foo');
      measure(perfs, repeatCall, 'non-trivial', 15, 'addEventListener', () => {
        trEl.addEventListener('click',listener);
      });

      measure(perfs, repeatCall, 'non-trivial', 16, 'textContent', () => {
        textContent = parent.textContent;
      });

      const secondChild = parent.querySelector('td[g]');
      const thirdChild = secondChild.nextElementSibling;
      measure(perfs, repeatCall, 'non-trivial', 17, 'insertBefore', () => {
        trEl.insertBefore(thirdChild,secondChild);
      });

      const textNode = secondChild.firstChild;
      measure(perfs, repeatCall, 'trivial', 15, 'data', () => {
        textData = textNode.data;
      });

      const div = thirdChild.appendChild(document.createElement('div'));
      measure(perfs, repeatCall, 'non-trivial', 18, 'attachShadow', () => {
        div.attachShadow({mode: 'open'});
      });

      measure(perfs, repeatCall, 'non-trivial', 19, 'createTreeWalker', () => {
        treeWalker = document.createTreeWalker(parent, NodeFilter.SHOW_ALL);
      });

      const iframe = document.querySelector("iframe");
      const iframeEl = iframe.contentDocument.body.firstChild;
      measure(perfs, repeatCall, 'non-trivial', 20, 'importNode', () => {
        const iframeElClone = document.importNode(iframeEl, true);
      });


      // Use all of the results, to ensure nothing is optimized out. Plus verify things worked as expected.
      assert(td2.nextSibling.nextSibling.getAttribute('g') === '7' && names.length === 8 && children.length === 6 &&
          bAttr === '2' && classList.length === 2 && textContent.length > 0 && thirdChild.children.length === 1 &&
          textNode.nodeType === 3 && textData.length > 10 && iframeEl.outerHTML === "<div></div>" &&
          'currentNode' in treeWalker,'Broken behavior');

      // Cleanup for repeat:
      trEl.setAttribute('c','not 3');
      trEl.removeEventListener('click',listener);
      trEl.insertBefore(secondChild,thirdChild);
      thirdChild.replaceChildren();
      while (parent.childNodes.length) {
        tplClone.appendChild(parent.firstChild);
      }
    });
  }
</script>

<div id=warnings></div>
<fieldset style="display:flex; border:0" id="controls">
  <div>
    <button id="run_baseline"></button>
    <pre id=baseline_log></pre>
  </div>
</fieldset>
<table style="display:none"><tbody></tbody></table>

<script>
  document.querySelector(
    "button#run_baseline"
  ).textContent = `Run benchmark, ${nRows} rows, ${nRuns} runs`;

  // Feature detection.
  if (!supportsGC()) {
    warnings.innerHTML = `Note: This benchmark produces less noisy measurements if garbage collection can be enabled. Try:
      <ul>
        <li>Chromium: add <pre style="display:inline">--js-flags="--expose-gc"</pre> to the command line</li>
        <li>WebKit: please let me know if you know how to enable</li>
        <li>Gecko: please let me know if you know how to enable</li>
      </ul>`;
  } else {
    warnings.innerHTML = `<div>âœ… Garbage collection enabled.</div><br>`;
  }

  function measure(perfs,repeatCall,category,index,field, operation) {
    if (!(field in perfs)) {
      perfs[field] = {};
    }
    if (!(repeatCall in perfs[field])) {
      perfs[field][repeatCall] = {sum:0, count:0, index, category};
    }
    const startTime = performance.now();
    operation();
    const endTime = performance.now();
    perfs[field][repeatCall].sum += endTime - startTime;
    perfs[field][repeatCall].count++;
  }

  function assert(cond,msg) {
    if (!cond) {
      msg = `Unexpected condition encountered in benchmark: ${msg}`;
      document.querySelector("#baseline_log").textContent = msg;
      throw Error(msg);
    }
  }

  async function runAndMeasureBenchmark() {
    controls.disabled = true;
    await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)));
    setTimeout(() => {controls.disabled = false},0);
    const tbodyRef = document.querySelector("tbody");
    const perfs = {}; // Record overall, across rows and runs.

    for (let i = 0; i < nRuns; i++) {
      // Reset the table between runs.
      document.querySelector("tbody").replaceChildren();
      garbageCollect();

      for (let i = 0; i < nRows; i++) {
        runBenchmarkRow(perfs, tbodyRef);
      }
    }

    // Convert to average times, plus double check for bad names and indices.
    let correctCount;
    Object.keys(perfs).forEach(key => {
      ["first","repeat"].forEach(repeatCall => {
        if (repeatCall in perfs[key]) {
          perfs[key][repeatCall].averageTime = perfs[key][repeatCall].sum / perfs[key][repeatCall].count;
          if (!correctCount) {
            correctCount = perfs[key][repeatCall].count;
          } else {
            assert(correctCount == perfs[key][repeatCall].count,`Duplicate name for ${key}`);
          }
        }
      });
    });
    return perfs;
  }

  function supportsGC() {
    return self.TestUtils?.gc || self.gc || self.GCController;
  }
  function garbageCollect() {
    if (!supportsGC())
      return;
    self.TestUtils?.gc && TestUtils.gc();
    self.gc && self.gc();
    self.GCController && GCController.collect();
  }

  document.querySelector("button#run_baseline").addEventListener("click", async () => {

    // Run the benchmark:
    const perfs = await runAndMeasureBenchmark();

    let report = '<table><thead><tr><th>Type</th><th>Benchmark</th><th>Time (us/call)</th></tr></thead>';
    Object.keys(perfs)
      .sort((a, b) => {
        return perfs[a].first.category.localeCompare(perfs[b].first.category) ||
            perfs[a].first.index - perfs[b].first.index;
      })
      .forEach(key => {
      ["first","repeat"].forEach(repeatCall => {
        if (repeatCall in perfs[key]) {
          report += `<tr>
            <td>${perfs[key][repeatCall].category}</td>
            <td>${key}${repeatCall !== "first" ? " (repeat)" : ""}</td>
            <td>${(1000*perfs[key][repeatCall].averageTime).toFixed(3)}</td>
          </tr>`;
        }
      });
    });
    report += `</table><br><br>template:<br>`;
    const log = document.querySelector("#baseline_log");
    log.innerHTML = report;
    const pre = document.createElement('pre');
    pre.innerText = templateHtml;
    log.appendChild(pre);
  });
</script>
